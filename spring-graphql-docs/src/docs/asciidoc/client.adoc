include::attributes.adoc[]




[[client]]
= Client

Spring for GraphQL includes client support for executing GraphQL requests over HTTP or
over WebSocket.



[[client-graphqlclient]]
== `GraphQlClient`

`GraphQlClient` defines a common workflow for executing GraphQL requests and
subscriptions that is independent of and agnostic to the underlying transport. To create
an instance, you'll need to start from either the <<client-httpgraphqlclient,
HttpGraphQlClient>> or the <<client-websocketgraphqlclient,WebSocketGraphQlClient>>
extensions.

The main purpose of a `GraphQlClient` extension is to provide a transport specific
`Builder`. There is also a common <<client-graphqlclient-builder>> in `GraphQlClient`
with configuration options that apply to any extension.



[[client-httpgraphqlclient]]
=== HTTP

`HttpGraphQlClient` uses
{spring-framework-ref-docs}/web-reactive.html#webflux-client[WebClient] to execute
GraphQL requests over HTTP.

[source,java,indent=0,subs="verbatim,quotes"]
----
WebClient webClient = ... ;
HttpGraphQlClient graphQlClient = HttpGraphQlClient.create(webClient);
----

The `HttpGraphQlClient` extension is nothing but a `GraphQlClient` with a specialized
builder. Once created, it exposes the same workflow for request execution that is
independent of the underlying transport.

This means you can only configure HTTP request details at build time, and
those apply to all requests through that client instance. To change HTTP request
details, use `mutate()` on an existing `HttpGraphQlClient` to create another
instance with different configuration:

[source,java,indent=0,subs="verbatim,quotes"]
----
    WebClient webClient = ... ;

	HttpGraphQlClient graphQlClient = HttpGraphQlClient.builder(webClient)
			.headers(headers -> headers.setBasicAuth("joe", "..."))
			.build();

	// Perform requests with graphQlClient...

	HttpGraphQlClient anotherGraphQlClient = graphQlClient.mutate()
			.headers(headers -> headers.setBasicAuth("peter", "..."))
			.build();

	// Perform requests with anotherGraphQlClient...

----



[[client-websocketgraphqlclient]]
=== WebSocket

`WebSocketGraphQlClient` uses
{spring-framework-ref-docs}/web-reactive.html#webflux-websocket-client[WebSocketClient]
from Spring WebFlux to execute GraphQL requests over WebSocket:

[source,java,indent=0,subs="verbatim,quotes"]
----
	String url = "http://localhost:8080/graphql";
	WebSocketClient client = new ReactorNettyWebSocketClient();

	WebSocketGraphQlClient graphQlClient = WebSocketGraphQlClient.builder(url, client).build();
----

Once created, `WebSocketGraphQlClient` exposes the same transport agnostic workflow for
request execution as any `GrahQlClient`. To change any transport details, use `mutate()`
on an existing `WebSocketGraphQlClient` to create another with different configuration:

[source,java,indent=0,subs="verbatim,quotes"]
----
	URI url = ... ;
	WebSocketClient client = ... ;

	WebSocketGraphQlClient graphQlClient = WebSocketGraphQlClient.builder(url, client)
			.headers(headers -> headers.setBasicAuth("joe", "..."))
			.build();

	// Use graphQlClient...

	WebSocketGraphQlClient anotherGraphQlClient = graphQlClient.mutate()
			.headers(headers -> headers.setBasicAuth("peter", "..."))
			.build();

	// Use anotherGraphQlClient...

----

A connection is established transparently when requests are made. There is only one
shared, active connection at a time. If the connection is lost, it is automatically
re-established on the next request.

`WebSocketGraphQlClient` also exposes lifecycle methods:

- `start()` - connect the WebSocket and initialize the GraphQL session. This can be used
on startup up to be ready for requests, but it is not required.
- `stop()` - cancels ongoing requests and subscriptions, and closes the connection. A
stopped client rejects new requests. Use `start()` to re-establish the connection and
allow requests again.



[[client-graphqlclient-builder]]
=== Builder

`GraphQlClient` defines a parent `Builder` with common configuration options for the
builders of all extensions. Currently, it has lets you configure a `DocumentSource`,
which is a strategy for loading the document for a request by file name.




[[client-requests]]
== Requests

Once you have a <<client-graphqlclient>>, you can begin to perform requests via
<<client-requests-retrieve, retrieve()>> or <<client-requests-execute, execute()>>
where the former is merely a shortcut for the latter.



[[client-requests-retrieve]]
=== Retrieve

The below retrieves and decodes the data for a query:

[source,java,indent=0,subs="verbatim,quotes"]
----
	String document = "{" +
			"  project(slug:\"spring-framework\") {" +
			"	name" +
			"	releases {" +
			"	  version" +
			"	}"+
			"  }" +
			"}";

	Mono<Project> projectMono = graphQlClient.document(document) <1>
			.retrieve("project") <2>
			.toEntity(Project.class); <3>
----
<1> The operation to perform
<2> Specify a path under the "data" key in the response map
<3> Decode the data at the path to the target type

The document is a `String` that could be a literal or produced through a code generated
request object. You can also define documents in files and use a
<<client-requests-document-source>> to resole them by file name.

The path is relative to the "data" key and uses a simple dot (".") separated notation
for nested fields with optional array indices for list elements, e.g. `"project.name"`,
`"project.releases[0].version"`, and so on.

Decoding can fail with `FieldAccessException` if the given path is not present in the
response map, or when the value is `null` and there is an error for the field.

By default, `FieldAccessException` is also raised on `retrieve` for partial data where
the field value exists but nested fields may be `null` with a field error. In such
cases, you can handle the exception to examine the errors and decide whether or how to
decode the partial data:

[source,java,indent=0,subs="verbatim,quotes"]
----
	Mono<Project> projectMono = graphQlClient.document(document)
			.retrieve("project")
			.toEntity(Project.class)
			.onErrorResume(FieldAccessException.class, ex -> {
				ResponseField field = ex.getField();
				// Use field to check nested field errors and/or decode
				// Return Mono with Project or an error
			});
----

TIP: The GraphQL spec considers a partial response or a partial field to be valid, and
it may be feasible to decode them. By contrast, a failed field (i.e. value not present or
is `null` with field error) or a failed response (no "data" key) are not valid and
attempts to decode those are always rejected.



[[client-requests-execute]]
=== Execute

The `retrieve` method is only a shortcut to decode from a single path to a higher level
object. For more control and access to the response, use the `execute` method.

For example:

[source,java,indent=0,subs="verbatim,quotes"]
----

	Mono<Project> projectMono = graphQlClient.document(document)
			.execute()
			.map(response -> {
				// Check response.isValid(), getErrors()

				ResponseField field = response.field("project");
				// Check field.hasValue(), getError()

				return field.toEntity(Project.class)
			});
----

You can use `execute` to check response errors, obtain different fields, check their
field errors and nested field errors, and/or decode their values.



[[client-requests-document-source]]
=== Document Source

The document for a request is a `String` that may be defined in a local variable or
constant, or it may be produced through a code generated request object.

Alternatively, you can also keep documents in files with extensions `.graphql` or `
.gql`, on the classpath or anywhere else, and refer to those by file name. For example,
given:

[source,graphql,indent=0,subs="verbatim,quotes"]
.src/main/resources/graphql/project.graphql
----
	query projectReleases($slug: ID!) {
		project(slug: $slug) {
			name
			releases {
				version
			}
		}
	}
----

You can then:

[source,java,indent=0,subs="verbatim,quotes"]
----
	Mono<Project> projectMono = graphQlClient.documentName("project") <1>
			.variable("slug", "spring-framework") <2>
			.retrieve()
			.toEntity(Project.class);
----
<1> Load the document from "project.graphql"
<2> Provide variable values.

The "JS GraphQL" plugin for IntelliJ supports GraphQL query files with code completion.

You can use the `GraphQlClient` <<client-graphqlclient-builder>> to customize the
`DocumentSource` for loading documents by names.



[[client-subscriptions]]
== Subscriptions

For a subscription operation, call `retrieveSubscription` instead of `retrieve` to
obtain a stream of responses rather than a single response:

[source,java,indent=0,subs="verbatim,quotes"]
----
	Flux<String> greetingFlux = client.document("subscription { greetings }")
			.retrieveSubscription("greeting")
			.toEntity(String.class);
----

Similar to the <<client-requests-retrieve>> vs <<client-requests-execute>> choice
for requests with a single response, the same choice is also available for subscriptions.
For example, for more control over each response, use `executeSubscription` instead of
`retrieveSubscription`:

[source,java,indent=0,subs="verbatim,quotes"]
----
	Flux<String> greetingFlux = client.document("subscription { greetings }")
			.executeSubscription()
			.map(response -> {
				// Check response.isValid(), getErrors()

				ResponseField field = response.field("greeting");
				// Check field.isValid(), getError()

				return field.toEntity(String.class)
			});
----



Subscriptions are supported only with the <<client-websocketgraphqlclient,
WebSocketGraphQlClient>> extension.








